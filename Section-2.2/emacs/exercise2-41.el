;;
;; Exercise 2.41
;;
;; Write a procedure to find all ordered triples of distinct positive integers
;; i, j, and k less than or equal to a given integer n that sum to a given
;; integer s.
;;

;;
;; First let's import the "unique-pairs" procedure from Exercise 2.40
;; (We'll name it the "ordered-pairs" procedure, for consistency).
;;
(defun ordered-pairs (n)
  (accumulate #'append
	      '()
	      (mapcar (lambda (i)
			(mapcar (lambda (j) (list i j))
				(enumerate-interval 1 (- i 1))))
		      (enumerate-interval 1 n))))

;;
;; The supporting procedures we need to make this procedure work are:
;;
(defun enumerate-interval (i j)
  (defun iter (count total)
    (cond ((<= count j) (iter (+ count 1) (append total (list count))))
	  (t
	   total)))
  (iter i '()))

(defun accumulate (op initial sequence)
  (defun iter (result rest)
    (if (null rest)
	result
      (iter (funcall op result (car rest))
	    (cdr rest))))
  (iter initial sequence))

;;
;; With the "ordered-pairs" procedure defined, we can define the following
;; "helper" function which gives us the set of all ordered triples, where
;; the "highest" (and "first") element is n:
;;
(defun ordered-triples-for-n (n)
  (mapcar (lambda (i) (append (list n) i)) (ordered-pairs (- n 1))))

;;
;; Note that it doesn't make sense to think of ordered triples of positive
;; integers less than 3:
;;
(ordered-triples-for-n 1)
;; ==> nil
(ordered-triples-for-n 2)
;; ==> nil
(ordered-triples-for-n 3)
;; ==> ((3 2 1))
(ordered-triples-for-n 4)
;; ==> ((4 2 1) (4 3 1) (4 3 2))

;;
;; Now we can finally define the "ordered-triples" procedure by accumulating
;; all the elements generated by the "ordered-triples-for-n" procedure:
;;
(defun flatmap (proc seq)
    (accumulate #'append '() (mapcar proc seq)))
(defun ordered-triples (n)
  (flatmap #'ordered-triples-for-n (enumerate-interval 1 n)))

;;
;; Run some tests:
;;
(ordered-triples 4)
;; ==> ((3 2 1) (4 2 1) (4 3 1) (4 3 2))
(ordered-triples 3)
;; ==> ((3 2 1))

(defun filter (pred seq)
  (cond ((null seq) '())
	((funcall pred (car seq))
	 (cons (car seq)
	       (filter pred (cdr seq))))
	(t
	 (filter pred (cdr seq)))))

;;
;; What we are seeking is all ordered triples, less than or equal to n,
;; that sum to a given integer s.
;;
(defun target-sum (n s)
  ;; Take an ordered triple as argument, and
  ;; see whether it equals our target.
  (defun bulls-eye? (seq)
    (if (= (length seq) 3)
	(= s (+ (car seq) (cadr seq) (car (cdr (cdr  seq)))))
      nil))

  ;; Implement the actual procedure.
  (filter #'bulls-eye? (ordered-triples n)))

;;
;; Run some tests:
;;
(target-sum 10 10)
;; ==> ((5 3 2) (5 4 1) (6 3 1) (7 2 1))
(target-sum 5 1)
;; ==> nil
(target-sum 5 7)
;; ==> ((4 2 1))
(target-sum 6 10)
;; ==> ((5 3 2) (5 4 1) (6 3 1))
